results_canton$stimmen_kandidat[p],
"'",
", source_update = 'BFS'",
" WHERE source_person_id = '",
results_canton$source_person_id[p],
"' AND election_ID = '",
ongoing_cantons_NR$election_ID[c],
"'"
)
rs <- dbSendQuery(mydb, sql_qry)
print(p)
}
#Update candidates results
print(paste0("Enter the results of ",nrow(results_canton)," candidates..."))
mydb <- connectDB(db_name = "sda_elections")
for (p in 1:nrow(results_canton)) {
sql_qry <- paste0(
"UPDATE candidates_results SET ",
" elected = '",
results_canton$flag_gewaehlt[p],
"'",
", votes = '",
results_canton$stimmen_kandidat[p],
"'",
", source_update = 'BFS'",
" WHERE source_person_id = '",
results_canton$source_person_id[p],
"' AND election_ID = '",
ongoing_cantons_NR$election_ID[c],
"'"
)
rs <- dbSendQuery(mydb, sql_qry)
print(p)
}
#,flag_gewaehlt == 1)
View(results_canton)
View(results_NR_cantons_candidates)
#Get parties results from Canton
mydb <- connectDB(db_name = "sda_elections")
rs <-
dbSendQuery(
mydb,
paste0(
"SELECT * FROM candidates_results WHERE date = '2023-10-22' AND council = 'NR'"
)
)
elected_candidates_overall <- fetch(rs, n = -1)
dbDisconnectAll()
test <- elected_candidates_overall %>%
full_join(results_NR_cantons_candidates)
View(test)
test <- elected_candidates_overall %>%
full_join(results_NR_cantons_candidates)
View(test)
BFS_API_URL <- "https://ckan.opendata.swiss/api/3/action/package_show?id=eidg-wahlen-2023"
#####START LOOP#####
#Flags
NR_new_results <- FALSE
NR_new_elected <- FALSE
SR_new_elected <- FALSE
NR_finished <- FALSE
#Load Databases
source("load_databases.R")
#Download data
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_daten"))
download.file(url_NR_candidates,
destfile = "data_NR_candidates.json",
method = "curl")
#Get URLs from API
response <-
GET(BFS_API_URL)
content <- content(response)$result$resources
###GET CANDIDATES DATA###
url_NR_candidates <-
as.data.frame(do.call(rbind, content))$download_url[[2]]
#Get timestamp and compare with old one
timestamp_candidates <- headers(HEAD(url_NR_candidates))$`last-modified`
timestamp_candidates_old <-
read.csv("./Timestamps/timestamp_candidates.txt", header = FALSE,sep = ";")[1, 1]
#Get URLs from API
response <-
GET(BFS_API_URL)
content <- content(response)$result$resources
###GET CANDIDATES DATA###
url_NR_candidates <-
as.data.frame(do.call(rbind, content))$download_url[[2]]
#Get timestamp and compare with old one
timestamp_candidates <- headers(HEAD(url_NR_candidates))$`last-modified`
timestamp_candidates_old <-
read.csv("./Timestamps/timestamp_candidates.txt", header = FALSE,sep = ";")[1, 1]
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
#Get timestamp and compare with old one
timestamp_candidates <- headers(HEAD(url_NR_candidates))$`last-modified`
timestamp_candidates_old <-
read.csv("./Timestamps/timestamp_candidates.txt", header = FALSE,sep = ";")[1, 1]
#Download data
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_daten"))
download.file(url_NR_candidates,
destfile = "data_NR_candidates.json",
method = "curl")
data_NR_candidates <-
fromJSON("data_NR_candidates.json", flatten = TRUE)
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
print("new candidates NR data downloaded!")
#Stand CH and Kantone
stand_ch_candidates <- data_NR_candidates$stand
stand_cantons_candidates <- data_NR_candidates$stand_kantone
#Results
results_NR_cantons_candidates <- data_NR_candidates$level_kantone %>%
left_join(parties_metadata,
by = join_by(kandidat_partei_id == bfs_id)) %>%
left_join(areas_metadata, join_by(kanton_nummer == bfs_ID))
#Create source ID
results_NR_cantons_candidates$source_person_id <-
paste0(
formatC(
results_NR_cantons_candidates$kanton_nummer,
width = 2,
flag = "0"
),
formatC(
results_NR_cantons_candidates$liste_nummer_bfs,
width = 2,
flag = "0"
),
formatC(
results_NR_cantons_candidates$kandidat_nummer,
width = 2,
flag = "0"
)
)
#Replace NA with 0
results_NR_cantons_candidates[is.na(results_NR_cantons_candidates)] <- 0
test <- elected_candidates_overall %>%
full_join(results_NR_cantons_candidates)
View(test)
test <- results_NR_cantons_candidates %>%
full_join(elected_candidates_overall)
View(test)
###COMMIT###
library(git2r)
git2r::config(user.name = "awp-finanznachrichten",user.email = "sw@awp.ch")
token <- read.csv(paste0(MAIN_PATH,"Github_Token/token.txt"),header=FALSE)[1,1]
git2r::cred_token(token)
gitadd()
gitcommit()
gitpush()
detach("package:git2r",unload=TRUE)
#Working Directory
MAIN_PATH <- "C:/Users/simon/OneDrive/"
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
#Get Libraries and needed Data
source("CONFIG.R")
#####START LOOP#####
#Flags
NR_new_results <- FALSE
NR_new_elected <- FALSE
SR_new_elected <- FALSE
NR_finished <- FALSE
#Load Databases
source("load_databases.R")
###Get BFS Data and update DB
source("NR_get_data_results.R")
source("NR_get_data_candidates.R")
#Working Directory
MAIN_PATH <- "C:/Users/simon/OneDrive/"
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
#Get Libraries and needed Data
source("CONFIG.R")
#####START LOOP#####
#Flags
NR_new_results <- FALSE
NR_new_elected <- FALSE
SR_new_elected <- FALSE
NR_finished <- FALSE
#Load Databases
source("load_databases.R")
###Get BFS Data and update DB
source("NR_get_data_results.R")
source("NR_get_data_candidates.R")
source("SR_get_data_candidates.R")
#,flag_gewaehlt == 1)
View(results_canton)
#Check if amount of distributed seats is correct
seats_check <- sum(results_canton$flag_gewaehlt == 1) == ongoing_cantons_NR$seats_available_NR[c]
sum(results_canton$flag_gewaehlt == 1)
ongoing_cantons_NR$seats_available_NR[c]
View(ongoing_cantons_NR)
print(paste0("new candidates results for canton ",ongoing_cantons_NR$area_ID[c]," found!"))
#Get elected candidates results from canton
results_canton <- results_NR_cantons_candidates %>%
filter(kanton_nummer == ongoing_cantons_NR$bfs_ID[c])
#,flag_gewaehlt == 1)
#Check if amount of distributed seats is correct
seats_check <- sum(results_canton$flag_gewaehlt == 1) == ongoing_cantons_NR$seats_available_NR[c]
#,flag_gewaehlt == 1)
View(results_canton)
source("C:/Users/simon/OneDrive/sda_eidgenoessische_wahlen_datafeed/NR_get_data_candidates.R", echo=TRUE)
source("C:/Users/simon/OneDrive/sda_eidgenoessische_wahlen_datafeed/NR_get_data_candidates.R", echo=TRUE)
#Working Directory
MAIN_PATH <- "C:/Users/simon/OneDrive/"
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
#Get Libraries and needed Data
source("CONFIG.R")
#####START LOOP#####
#Flags
NR_new_results <- FALSE
NR_new_elected <- FALSE
SR_new_elected <- FALSE
NR_finished <- FALSE
#Load Databases
source("load_databases.R")
###Get BFS Data and update DB
source("NR_get_data_results.R")
source("NR_get_data_candidates.R")
source("SR_get_data_candidates.R")
#Load Databases again
source("load_databases.R")
###CANTON RESULTS###
##Check: Canton completed?
#Get counted cantons
counted_cantons_all <- election_metadata %>%
filter(date == "2023-10-22",
grepl("finished",status) == TRUE) %>%
left_join(areas_metadata) %>%
left_join(status_texts) %>%
left_join(output_overview) %>%
filter(area_type == "canton")
#Get counted cantons NR and SR
counted_cantons <- counted_cantons_all %>%
filter(council == "NR")
counted_cantons_SR <- counted_cantons_all %>%
filter(council == "SR")
#Get intermediate results SR
intermediate_cantons_SR <- election_metadata %>%
filter(date == "2023-10-22",
grepl("ongoing",status) == TRUE,
remarks == "new data available") %>%
left_join(areas_metadata) %>%
left_join(status_texts) %>%
left_join(output_overview) %>%
filter(area_type == "canton",
council == "SR")
###INTERMEDIATE RESULTS NATIONALRAT###
check_intermediate <- intermediate_timecheck %>%
filter(hour == hour(Sys.time()))
source("load_databases.R")
source("All_prepare_results.R")
source("NR_text_intermediate.R")
paste0(DEFAULT_EMAILS,",inland@keystone-ats.ch, suisse@keystone-ats.ch")
#Get Libraries and needed Data
source("CONFIG.R")
paste0(DEFAULT_EMAILS,",inland@keystone-ats.ch, suisse@keystone-ats.ch")
#Load Databases again
source("load_databases.R")
###CANTON RESULTS###
##Check: Canton completed?
#Get counted cantons
counted_cantons_all <- election_metadata %>%
filter(date == "2023-10-22",
grepl("finished",status) == TRUE) %>%
left_join(areas_metadata) %>%
left_join(status_texts) %>%
left_join(output_overview) %>%
filter(area_type == "canton")
#Get counted cantons NR and SR
counted_cantons <- counted_cantons_all %>%
filter(council == "NR")
counted_cantons_SR <- counted_cantons_all %>%
filter(council == "SR")
#Get intermediate results SR
intermediate_cantons_SR <- election_metadata %>%
filter(date == "2023-10-22",
grepl("ongoing",status) == TRUE,
remarks == "new data available") %>%
left_join(areas_metadata) %>%
left_join(status_texts) %>%
left_join(output_overview) %>%
filter(area_type == "canton",
council == "SR")
###INTERMEDIATE RESULTS NATIONALRAT###
check_intermediate <- intermediate_timecheck %>%
filter(hour == hour(Sys.time()))
source("SR_get_data_candidates.R")
#Download data
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_daten"))
data_SR_candidates <-
fromJSON("data_SR_candidates.json", flatten = TRUE)
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
print("new candidates SR data downloaded!")
#Stand CH and Kantone
stand_ch_candidates <- data_SR_candidates$stand
stand_cantons_candidates <- data_SR_candidates$stand_kantone
#Results
results_SR_cantons_candidates <- data_SR_candidates$kandidierende %>%
left_join(parties_metadata,
by = join_by(kandidat_partei_id == bfs_id)) %>%
left_join(areas_metadata, join_by(kanton_nummer == bfs_ID))
View(stand_cantons_candidates)
#Load Databases again
source("load_databases.R")
###CANTON RESULTS###
##Check: Canton completed?
#Get counted cantons
counted_cantons_all <- election_metadata %>%
filter(date == "2023-10-22",
grepl("finished",status) == TRUE) %>%
left_join(areas_metadata) %>%
left_join(status_texts) %>%
left_join(output_overview) %>%
filter(area_type == "canton")
#Get counted cantons NR and SR
counted_cantons <- counted_cantons_all %>%
filter(council == "NR")
counted_cantons_SR <- counted_cantons_all %>%
filter(council == "SR")
#Get intermediate results SR
intermediate_cantons_SR <- election_metadata %>%
filter(date == "2023-10-22",
grepl("ongoing",status) == TRUE,
remarks == "new data available") %>%
left_join(areas_metadata) %>%
left_join(status_texts) %>%
left_join(output_overview) %>%
filter(area_type == "canton",
council == "SR")
###INTERMEDIATE RESULTS NATIONALRAT###
check_intermediate <- intermediate_timecheck %>%
filter(hour == hour(Sys.time()))
c <- 3
#Generate Output
source("NR_text_results.R")
#Generate Output
source("NR_text_candidates.R")
## Function purpose: Sends Alerts if a candidate with a note (= VIP) is elected
## Important to know: Utils.R must be loaded
##
## Input
## canton: Default NULL (don't filter), String with two-chars to indicate canton to filter results
## council: String "NR"/"SR" to indicate council to filter results
##
## Return
## result: Sends E-Mail with alert
########################
canton <- "ZH"
council <- "NA"
canton_filter <- ""
if (!is.null(canton)) {
canton_filter <- paste0(" AND area_id = ", quote_str(canton), " ")
}
## Get Data
con <- connectDB(db_name = 'sda_elections')
sqlstr <- paste0("SELECT * FROM
(SELECT * FROM
sda_elections.candidates c
WHERE council = ", quote_str(council), canton_filter, ") c
JOIN sda_elections.people_metadata p ON c.person_id = p.id
WHERE not note is null AND note <> '';")
rs <- dbGetQuery(con, sqlstr)
vips_all <- rs
dbDisconnectAll()
## Filter data for cantons
cantons <- unique(vips_all$area_id)
cantons <- cantons[order(cantons)]
cantons
## Function purpose: Sends Alerts if a candidate with a note (= VIP) is elected
## Important to know: Utils.R must be loaded
##
## Input
## canton: Default NULL (don't filter), String with two-chars to indicate canton to filter results
## council: String "NR"/"SR" to indicate council to filter results
##
## Return
## result: Sends E-Mail with alert
########################
council <- "NR"
## Filter for canton
canton_filter <- ""
if (!is.null(canton)) {
canton_filter <- paste0(" AND area_id = ", quote_str(canton), " ")
}
## Get Data
con <- connectDB(db_name = 'sda_elections')
sqlstr <- paste0("SELECT * FROM
(SELECT * FROM
sda_elections.candidates c
WHERE council = ", quote_str(council), canton_filter, ") c
JOIN sda_elections.people_metadata p ON c.person_id = p.id
WHERE not note is null AND note <> '';")
rs <- dbGetQuery(con, sqlstr)
vips_all <- rs
dbDisconnectAll()
## Filter data for cantons
cantons <- unique(vips_all$area_id)
cantons <- cantons[order(cantons)]
alert <- ""
for (i in 1:length(cantons)) {
alert <- paste0(alert, cantons[i], " ")
vips <- vips_all[vips_all$area_id == cantons[i], ]
if (nrow(vips) > 0) {
elected <- vips[vips$elected == 1, ]
unelected <- vips[vips$elected == 0, ]
if (nrow(elected) > 0) {
alert <- paste0(alert, "ELECTED\n\n")
alert <- paste0(alert, paste0(elected$firstname, " ", elected$lastname,
", ", elected$shortname_de, " (", elected$note, ") ",
format(elected$votes, big.mark = "'"), " ", "votes",
collapse = "\n"), "\n\n")
}
if (nrow(unelected) > 0) {
alert <- paste0(alert, "UNELECTED\n\n")
alert <- paste0(alert, paste0(unelected$firstname, " ", unelected$lastname,
", ", unelected$shortname_de, " (", unelected$note, ") ",
format(unelected$votes, big.mark = "'"), " ", "votes",
collapse = "\n"), "\n\n")
}
}
}
source("C:/Users/simon/OneDrive/sda_eidgenoessische_wahlen_datafeed/Functions/function_VIP_alert.R", echo=TRUE)
cat(alert)
source("C:/Users/simon/OneDrive/sda_eidgenoessische_wahlen_datafeed/Communities_live_data.R", echo=TRUE)
View(nationalrat_gemeinden_dw)
source("C:/Users/simon/OneDrive/sda_eidgenoessische_wahlen_datafeed/Communities_live_data.R", echo=TRUE)
###COMMIT###
library(git2r)
git2r::config(user.name = "awp-finanznachrichten",user.email = "sw@awp.ch")
token <- read.csv(paste0(MAIN_PATH,"Github_Token/token.txt"),header=FALSE)[1,1]
git2r::cred_token(token)
gitadd()
gitcommit()
gitpush()
detach("package:git2r",unload=TRUE)
source("Communities_publish_charts.R")
#Participation
nationalrat_gemeinden_dw <- add_participations(nationalrat_gemeinden_dw,
results_NR_communities_voterturnout,
texts_spreadsheet_UrLena,
area = "ch")
text_highest <- texts_spreadsheet_UrLena %>%
filter(Text_ID == "Add_highest_in_CH")
text_lowest <- texts_spreadsheet_UrLena %>%
filter(Text_ID == "Add_lowest_in_CH")
text_highest <- texts_spreadsheet_UrLena %>%
filter(Text_ID == "Add_Participation_highest_in_CH")
text_lowest <- texts_spreadsheet_UrLena %>%
filter(Text_ID == "Add_Participation_lowest_in_CH")
text_top10 <- texts_spreadsheet_UrLena %>%
filter(Text_ID == "Add_Participation_Top10_in_CH")
text_bottom10 <- texts_spreadsheet_UrLena %>%
filter(Text_ID == "Add_Participation_Bottom10_in_CH")
results <- results_NR_communities_voterturnout %>%
filter(is.na(wahlbeteiligung) == FALSE) %>%
arrange(desc(wahlbeteiligung)
)
View(results)
View(results_NR_communities)
results_NR_communities <- data_NR_results$level_gemeinden
results_NR_communities <- results_NR_communities %>%
filter(gemeinde_nummer < 9000)
left_join(parties_metadata,
by = join_by(partei_id == bfs_id))
results_NR_communities <- data_NR_results$level_gemeinden
results_NR_communities <- results_NR_communities %>%
filter(gemeinde_nummer < 9000) %>%
left_join(parties_metadata,
by = join_by(partei_id == bfs_id))
results_NR_communities_voterturnout <- data_NR_voterturnout$level_gemeinden %>%
filter(gemeinde_nummer < 9000)
View(results_NR_communities_voterturnout)
results <- results_NR_communities_voterturnout %>%
filter(is.na(wahlbeteiligung) == FALSE) %>%
arrange(desc(wahlbeteiligung)
)
View(results)
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_daten"))
data_NR_results <-
fromJSON("data_NR_results.json", flatten = TRUE)
data_NR_voterturnout <-
fromJSON("data_NR_voterturnout.json", flatten = TRUE)
setwd(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_datafeed"))
results_NR_communities <- data_NR_results$level_gemeinden
results_NR_communities <- results_NR_communities %>%
left_join(parties_metadata,
by = join_by(partei_id == bfs_id))
stand_ch <- data_NR_results$stand
stand_cantons <- data_NR_results$stand_kantone
results_NR_communities_voterturnout <- data_NR_voterturnout$level_gemeinden %>%
filter(gemeinde_nummer < 9000)
results_NR_CH <- data_NR_results$level_ch
Vieew(results_NR_cantons_voterturnout)
View(results_NR_cantons_voterturnout)
View(results_NR_communities_voterturnout)
#Participation
nationalrat_gemeinden_dw <- add_participations(nationalrat_gemeinden_dw,
results_NR_communities_voterturnout,
texts_spreadsheet_UrLena,
area = "ch")
View(results_NR_communities_voterturnout)
data_NR_voterturnout<- fromJSON(paste0(MAIN_PATH,"sda_eidgenoessische_wahlen_daten/Testdaten/Testdata_NR_2023_Completed/sd-t-17.02-NRW2023-wahlbeteiligung.json"), flatten = TRUE)
results_NR_communities_voterturnout <- data_NR_voterturnout$level_gemeinden %>%
filter(gemeinde_nummer < 9000)
source("Communities_live_data.R")
source("Communities_publish_charts.R")
###COMMIT###
library(git2r)
git2r::config(user.name = "awp-finanznachrichten",user.email = "sw@awp.ch")
token <- read.csv(paste0(MAIN_PATH,"Github_Token/token.txt"),header=FALSE)[1,1]
git2r::cred_token(token)
gitadd()
gitcommit()
gitpush()
detach("package:git2r",unload=TRUE)
